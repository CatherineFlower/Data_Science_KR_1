# Чеклист реализованных функций для КР-4

## Файл: `db.py`

### Функции для работы с представлениями (VIEW и MATERIALIZED VIEW)

#### ✅ `list_views(schema: str = "app", materialized: bool = False)`
**Описание:** Получить список представлений в схеме  
**Параметры:**
- `schema` - имя схемы (по умолчанию "app")
- `materialized` - если True, возвращает MATERIALIZED VIEW, иначе обычные VIEW

**Возвращает:** Список словарей с ключами:
- `view_name` - имя представления
- `size` - размер (только для MATERIALIZED VIEW)
- `comment` - комментарий (если есть)

**Как проверить в интерфейсе:**
1. Запустите приложение и войдите как администратор (логин: `admin`, пароль: `123`)
2. В главном меню нажмите кнопку **"Админ-панель"**
3. В админ-панели найдите и откройте **"Управление представлениями"** (Views Manager)
4. В открывшемся окне выберите вкладку **"Обычные VIEW"**
5. Нажмите кнопку **"Обновить список"** вверху окна
6. **Ожидаемый результат:** В списке слева должны отображаться все обычные VIEW из схемы `app` (например, `v_domain_current_state`, `v_ddos_events_last_hour`)
7. Переключитесь на вкладку **"MATERIALIZED VIEW"** и нажмите **"Обновить список"**
8. **Ожидаемый результат:** В списке должны отображаться только материализованные представления (если они есть)

**Техническая проверка (для разработчиков):**
- [ ] Функция `list_views(materialized=False)` возвращает список обычных VIEW
- [ ] Функция `list_views(materialized=True)` возвращает список MATERIALIZED VIEW
- [ ] Корректно обрабатывает пустую схему
- [ ] Возвращает пустой список, если представлений нет

---

#### ✅ `list_all_views(schema: str = "app")`
**Описание:** Получить список всех представлений (обычных и материализованных)  
**Параметры:**
- `schema` - имя схемы (по умолчанию "app")

**Возвращает:** Список словарей с ключами:
- `view_name` - имя представления
- `is_materialized` - True для MATERIALIZED VIEW, False для обычных
- `size` - размер (только для MATERIALIZED VIEW)
- `comment` - комментарий (если есть)

**Как проверить в интерфейсе:**
1. В окне **"Управление представлениями"** нажмите **"Обновить список"** на вкладке **"Обычные VIEW"**
2. **Ожидаемый результат:** В списке отображаются все обычные VIEW, отсортированные по имени
3. Переключитесь на вкладку **"MATERIALIZED VIEW"** и нажмите **"Обновить список"**
4. **Ожидаемый результат:** В списке отображаются все материализованные представления

**Техническая проверка (для разработчиков):**
- [ ] Функция `list_all_views()` возвращает и обычные, и материализованные представления
- [ ] Поле `is_materialized` корректно установлено для каждого типа (True для MATERIALIZED VIEW, False для обычных)
- [ ] Список отсортирован по имени представления

---

#### ✅ `get_view_definition(schema: str, view_name: str, materialized: bool = False)`
**Описание:** Получить SQL определение представления  
**Параметры:**
- `schema` - имя схемы
- `view_name` - имя представления
- `materialized` - True для MATERIALIZED VIEW, False для обычных VIEW

**Возвращает:** Строку с SQL определением представления или None, если не найдено

**Как проверить в интерфейсе:**
1. В окне **"Управление представлениями"** выберите вкладку **"Обычные VIEW"**
2. В списке слева кликните на любое представление (например, `v_domain_current_state`)
3. **Ожидаемый результат:** В правой части окна в текстовом поле должно отобразиться SQL-определение представления (SELECT запрос)
4. Проверьте, что определение начинается с `SELECT` и содержит корректный SQL
5. Выберите вкладку **"MATERIALIZED VIEW"** и кликните на материализованное представление (если есть)
6. **Ожидаемый результат:** Также должно отобразиться SQL-определение

**Техническая проверка (для разработчиков):**
- [ ] Функция `get_view_definition()` возвращает корректное определение для обычного VIEW
- [ ] Функция `get_view_definition(materialized=True)` возвращает корректное определение для MATERIALIZED VIEW
- [ ] Возвращает None для несуществующего представления
- [ ] Определение содержит валидный SQL (можно выполнить через `EXPLAIN`)

---

#### ✅ `create_view(schema: str, view_name: str, definition: str, materialized: bool = False, with_data: bool = True)`
**Описание:** Создать представление (обычное или материализованное)  
**Параметры:**
- `schema` - имя схемы
- `view_name` - имя представления (валидируется: только буквы, цифры, подчеркивания)
- `definition` - SQL запрос (SELECT ...)
- `materialized` - True для MATERIALIZED VIEW, False для обычного VIEW
- `with_data` - для MATERIALIZED VIEW: загружать данные сразу (True) или нет (False)

**Возвращает:** None (вызывает исключение при ошибке)

**Как проверить в интерфейсе:**

**Создание обычного VIEW:**
1. В окне **"Управление представлениями"** нажмите кнопку **"Создать VIEW"** внизу окна
2. В открывшемся диалоге:
   - Введите имя представления (например, `test_view`)
   - В большое текстовое поле введите SQL запрос: `SELECT domain, state FROM app.tracked_domain`
   - Нажмите **"Создать"**
3. **Ожидаемый результат:** 
   - Появится сообщение об успешном создании
   - Новое представление появится в списке обычных VIEW
   - При клике на него отобразится введённое SQL-определение

**Создание MATERIALIZED VIEW:**
1. Нажмите кнопку **"Создать MATERIALIZED VIEW"**
2. Введите имя (например, `test_mat_view`)
3. Введите SQL запрос: `SELECT domain, COUNT(*) as cnt FROM app.tracked_domain GROUP BY domain`
4. Отметьте чекбокс **"Загрузить данные сразу"** (WITH DATA)
5. Нажмите **"Создать"**
6. **Ожидаемый результат:**
   - Сообщение об успешном создании
   - Представление появится на вкладке **"MATERIALIZED VIEW"**
   - При выборе отображается размер представления

**Проверка валидации:**
1. Попробуйте создать VIEW с именем, содержащим спецсимволы (например, `test-view!`)
2. **Ожидаемый результат:** Появится сообщение об ошибке, что имя может содержать только буквы, цифры и подчёркивания
3. Попробуйте создать VIEW с некорректным SQL (например, `SELECT FROM`)
4. **Ожидаемый результат:** Появится сообщение об ошибке SQL с описанием проблемы

**Техническая проверка (для разработчиков):**
- [ ] Функция `create_view()` создаёт обычное VIEW с корректным SQL
- [ ] Функция `create_view(materialized=True, with_data=True)` создаёт MATERIALIZED VIEW с WITH DATA
- [ ] Функция `create_view(materialized=True, with_data=False)` создаёт MATERIALIZED VIEW с WITH NO DATA
- [ ] Выбрасывает ValueError при некорректном имени (спецсимволы, пробелы)
- [ ] Выбрасывает исключение при некорректном SQL в definition
- [ ] Логирует операцию создания через `logger.info()`

---

#### ✅ `drop_view(schema: str, view_name: str, materialized: bool = False, cascade: bool = False)`
**Описание:** Удалить представление  
**Параметры:**
- `schema` - имя схемы
- `view_name` - имя представления
- `materialized` - True для MATERIALIZED VIEW, False для обычного VIEW
- `cascade` - использовать CASCADE при удалении

**Возвращает:** None

**Как проверить в интерфейсе:**
1. В окне **"Управление представлениями"** выберите любое представление в списке
2. Нажмите кнопку **"Удалить"** (обычно справа от списка или внизу)
3. **Ожидаемый результат:** 
   - Появится диалог подтверждения "Вы уверены, что хотите удалить представление?"
   - При нажатии **"Да"** представление удаляется
   - Представление исчезает из списка
   - Появляется сообщение об успешном удалении
4. Попробуйте удалить несуществующее представление (если возможно)
5. **Ожидаемый результат:** Не должно быть ошибки, операция завершается корректно

**Техническая проверка (для разработчиков):**
- [ ] Функция `drop_view()` удаляет обычное VIEW
- [ ] Функция `drop_view(materialized=True)` удаляет MATERIALIZED VIEW
- [ ] Работает с IF EXISTS (не падает, если представления нет)
- [ ] `drop_view(cascade=True)` удаляет зависимые объекты (если есть)
- [ ] Логирует операцию удаления через `logger.info()`

---

#### ✅ `refresh_materialized_view(schema: str, view_name: str, concurrently: bool = False)`
**Описание:** Обновить данные в материализованном представлении  
**Параметры:**
- `schema` - имя схемы
- `view_name` - имя MATERIALIZED VIEW
- `concurrently` - использовать CONCURRENTLY (требует уникальный индекс)

**Возвращает:** None (вызывает исключение при ошибке)

**Как проверить в интерфейсе:**
1. В окне **"Управление представлениями"** перейдите на вкладку **"MATERIALIZED VIEW"**
2. Выберите любое материализованное представление в списке
3. Нажмите кнопку **"Обновить"** или **"Refresh"** (обычно рядом с кнопкой удаления)
4. **Ожидаемый результат:**
   - Появится сообщение об успешном обновлении
   - Данные в представлении обновятся (если были изменения в исходных таблицах)
5. Если у представления есть уникальный индекс, попробуйте обновить с опцией **"CONCURRENTLY"** (если такая кнопка есть)
6. **Ожидаемый результат:** Обновление проходит без блокировки таблицы

**Проверка ошибок:**
1. Попробуйте обновить несуществующее представление
2. **Ожидаемый результат:** Появится понятное сообщение об ошибке

**Техническая проверка (для разработчиков):**
- [ ] Функция `refresh_materialized_view()` обновляет MATERIALIZED VIEW обычным способом
- [ ] Функция `refresh_materialized_view(concurrently=True)` обновляет с CONCURRENTLY (если есть уникальный индекс)
- [ ] Выбрасывает понятное исключение при CONCURRENTLY без индекса
- [ ] Выбрасывает исключение для несуществующего представления
- [ ] Логирует операцию обновления через `logger.info()`

---

#### ✅ `view_exists(schema: str, view_name: str, materialized: bool = False) -> bool`
**Описание:** Проверить существование представления  
**Параметры:**
- `schema` - имя схемы
- `view_name` - имя представления
- `materialized` - True для MATERIALIZED VIEW, False для обычного VIEW

**Возвращает:** True если представление существует, False иначе

**Как проверить в интерфейсе:**
1. В окне **"Управление представлениями"** выберите вкладку **"Обычные VIEW"**
2. Кликните на существующее представление (например, `v_domain_current_state`)
3. **Ожидаемый результат:** Представление выделяется, справа отображается его определение
4. Перейдите на вкладку **"MATERIALIZED VIEW"** и выберите материализованное представление (если есть)
5. **Ожидаемый результат:** Представление также отображается и доступно для просмотра

**Техническая проверка (для разработчиков):**
- [ ] Функция `view_exists()` возвращает True для существующего обычного VIEW
- [ ] Функция `view_exists(materialized=True)` возвращает True для существующего MATERIALIZED VIEW
- [ ] Возвращает False для несуществующего представления
- [ ] Корректно различает обычные и материализованные представления (не путает типы)

---

#### ✅ `get_materialized_view_info(schema: str, view_name: str)`
**Описание:** Получить детальную информацию о материализованном представлении  
**Параметры:**
- `schema` - имя схемы
- `view_name` - имя MATERIALIZED VIEW

**Возвращает:** Словарь с ключами:
- `view_name` - имя представления
- `total_size` - общий размер (включая индексы)
- `table_size` - размер таблицы данных
- `comment` - комментарий (если есть)
- `index_count` - количество индексов

Или None, если представление не найдено

**Как проверить в интерфейсе:**
1. В окне **"Управление представлениями"** перейдите на вкладку **"MATERIALIZED VIEW"**
2. Выберите любое материализованное представление в списке
3. **Ожидаемый результат:** 
   - В правой части окна должна отображаться информация о представлении:
     - Имя представления
     - Общий размер (например, "128 kB" или "2.5 MB")
     - Размер таблицы данных
     - Количество индексов (если есть)
     - Комментарий (если задан)
4. Размеры должны отображаться в читаемом формате (не в байтах, а в kB/MB/GB)

**Техническая проверка (для разработчиков):**
- [ ] Функция `get_materialized_view_info()` возвращает корректную информацию для существующего MATERIALIZED VIEW
- [ ] Размеры отображаются в читаемом формате через `pg_size_pretty()` (kB, MB, GB)
- [ ] Возвращает None для несуществующего представления
- [ ] Корректно считает количество индексов через `pg_indexes`

---

## Практические сценарии проверки

### Сценарий 1: Создание и просмотр обычного VIEW

**Шаги в интерфейсе:**
1. Запустите приложение, войдите как администратор
2. Откройте **Админ-панель** → **"Управление представлениями"**
3. Нажмите **"Создать VIEW"**
4. Введите имя: `test_user_domains`
5. Введите SQL: `SELECT u.login, d.domain, d.current_state FROM app.app_user u JOIN app.tracked_domain d ON u.id = d.user_id`
6. Нажмите **"Создать"**
7. **Ожидаемый результат:** Сообщение "VIEW успешно создан", представление появилось в списке
8. Кликните на созданное представление в списке
9. **Ожидаемый результат:** Справа отображается введённое SQL-определение
10. Нажмите **"Удалить"** и подтвердите удаление
11. **Ожидаемый результат:** Представление исчезло из списка

**Техническая проверка:**
- [ ] `list_views()` возвращает созданное VIEW
- [ ] `get_view_definition()` возвращает корректное определение
- [ ] `view_exists()` возвращает True до удаления, False после

---

### Сценарий 2: Создание и обновление MATERIALIZED VIEW

**Шаги в интерфейсе:**
1. В окне **"Управление представлениями"** перейдите на вкладку **"MATERIALIZED VIEW"**
2. Нажмите **"Создать MATERIALIZED VIEW"**
3. Введите имя: `test_domain_stats`
4. Введите SQL: `SELECT domain, COUNT(*) as metric_count FROM app.metric_sample GROUP BY domain`
5. Отметьте **"Загрузить данные сразу"**
6. Нажмите **"Создать"**
7. **Ожидаемый результат:** Сообщение об успехе, представление появилось на вкладке MATERIALIZED VIEW
8. Выберите созданное представление
9. **Ожидаемый результат:** Отображается размер представления (например, "64 kB")
10. Внесите изменения в таблицу `app.metric_sample` (через админ-панель или напрямую в БД)
11. Нажмите **"Обновить"** на представлении
12. **Ожидаемый результат:** Сообщение об успешном обновлении, данные обновились
13. Удалите представление

**Техническая проверка:**
- [ ] `get_materialized_view_info()` возвращает корректную информацию о размере
- [ ] `refresh_materialized_view()` обновляет данные
- [ ] После обновления данные соответствуют текущему состоянию таблиц

---

### Сценарий 3: Валидация и обработка ошибок

**Шаги в интерфейсе:**
1. Нажмите **"Создать VIEW"**
2. Попробуйте ввести имя с спецсимволами: `test-view!`
3. **Ожидаемый результат:** Появится ошибка "Имя может содержать только буквы, цифры и подчёркивания"
4. Введите корректное имя, но некорректный SQL: `SELECT FROM app.tracked_domain`
5. Нажмите **"Создать"**
6. **Ожидаемый результат:** Появится сообщение об ошибке SQL с описанием проблемы
7. Попробуйте обновить несуществующий MATERIALIZED VIEW
8. **Ожидаемый результат:** Понятное сообщение об ошибке

**Техническая проверка:**
- [ ] `create_view()` выбрасывает ValueError при некорректном имени
- [ ] `create_view()` выбрасывает исключение при некорректном SQL
- [ ] `refresh_materialized_view()` выбрасывает исключение для несуществующего представления

---

### Сценарий 4: Получение списков представлений

**Шаги в интерфейсе:**
1. Создайте 2-3 обычных VIEW через интерфейс
2. Создайте 1-2 MATERIALIZED VIEW
3. В окне **"Управление представлениями"** перейдите на вкладку **"Обычные VIEW"**
4. Нажмите **"Обновить список"**
5. **Ожидаемый результат:** В списке отображаются только созданные обычные VIEW, отсортированные по имени
6. Перейдите на вкладку **"MATERIALIZED VIEW"**
7. Нажмите **"Обновить список"**
8. **Ожидаемый результат:** В списке отображаются только материализованные представления

**Техническая проверка:**
- [ ] `list_views(materialized=False)` возвращает только обычные VIEW
- [ ] `list_views(materialized=True)` возвращает только MATERIALIZED VIEW
- [ ] `list_all_views()` возвращает все представления с флагом `is_materialized`

---

## SQL запросы для ручной проверки

### Проверить список обычных VIEW:
```sql
SELECT table_name 
FROM information_schema.views 
WHERE table_schema = 'app' 
ORDER BY table_name;
```

### Проверить список MATERIALIZED VIEW:
```sql
SELECT c.relname 
FROM pg_class c
JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE n.nspname = 'app' AND c.relkind = 'm'
ORDER BY c.relname;
```

### Получить определение VIEW:
```sql
SELECT view_definition 
FROM information_schema.views 
WHERE table_schema = 'app' AND table_name = 'имя_view';
```

### Получить определение MATERIALIZED VIEW:
```sql
SELECT pg_get_viewdef('app.имя_view'::regclass, true);
```

---

## Статус реализации

- ✅ Все функции добавлены в `db.py`
- ⏳ Тестирование функций
- ⏳ Интеграция в GUI модули

---

## Примечания

- Все функции используют существующую инфраструктуру `get_conn()`, `run_select()`, логирование
- Функции следуют стилю кода проекта
- Обработка ошибок через исключения с понятными сообщениями
- Логирование всех DDL операций через `logger.info()`

